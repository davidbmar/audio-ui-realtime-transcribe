<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Recorder - CloudDrive</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="audio-ui-styles.css">
    <link rel="stylesheet" href="styles.css">
    <style>
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <div id="debug-log" class="debug-log collapsed"></div>
    <div id="test-panel" class="test-panel collapsed">
        <div class="panel-header" onclick="toggleTestPanel()">
            <h4>Test Panel</h4>
            <span class="toggle-btn">‚ñº</span>
        </div>
        <div class="panel-content">
            <button onclick="window.testRecord()">üé§ Test Record 10s</button><br>
            <button onclick="window.testPlayback()">‚ñ∂Ô∏è Test Playback</button><br>
            <button onclick="window.clearDebug()">üóëÔ∏è Clear Debug</button><br>
            <button onclick="window.exportLogs()">üìã Copy Logs</button><br>
            <button onclick="toggleDebugLog()">üëÅÔ∏è Toggle Debug Log</button><br>
            <small>Authenticated Audio</small>
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Configuration - to be updated after deployment
        const config = {
            userPoolId: 'us-east-2_kUXJTqSBx',
            userPoolClientId: '3hkkor3jfohtvbu0g4lc7c96qq',
            identityPoolId: 'us-east-2:77a92592-0d49-442e-a7a8-70eb6d8ece33',
            region: 'us-east-2',
            apiUrl: 'https://dvae4jz4fkq7l.cloudfront.net/api/data',
            audioApiUrl: 'https://mbgdc7wlc9.execute-api.us-east-2.amazonaws.com/dev/api/audio',
            appUrl: 'https://dvae4jz4fkq7l.cloudfront.net'
        };

        // Debug logging
        window.debugLogs = [];
        const log = (message) => {
            console.log(message);
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `${timestamp}: ${message}`;
            window.debugLogs.push(logMessage);
            
            const debugElement = document.getElementById('debug-log');
            if (debugElement) {
                debugElement.innerHTML += `<div>${logMessage}</div>`;
                debugElement.scrollTop = debugElement.scrollHeight;
            }
        };

        // Panel toggle functions
        window.toggleTestPanel = () => {
            const panel = document.getElementById('test-panel');
            const toggleBtn = panel.querySelector('.toggle-btn');
            
            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                toggleBtn.textContent = '‚ñ≤';
            } else {
                panel.classList.add('collapsed');
                toggleBtn.textContent = '‚ñº';
            }
        };

        window.toggleDebugLog = () => {
            const debugLog = document.getElementById('debug-log');
            
            if (debugLog.classList.contains('collapsed')) {
                debugLog.classList.remove('collapsed');
            } else {
                debugLog.classList.add('collapsed');
            }
        };

        // Test functions
        window.clearDebug = () => {
            document.getElementById('debug-log').innerHTML = '';
            window.debugLogs = [];
        };

        window.exportLogs = () => {
            const logs = window.debugLogs.join('\n');
            navigator.clipboard.writeText(logs).then(() => {
                alert('Debug logs copied to clipboard!');
            });
        };

        // Authentication helper functions
        const getAuthToken = () => {
            return localStorage.getItem('id_token');
        };

        const getUserFromToken = () => {
            const token = getAuthToken();
            if (!token) return null;
            
            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                return {
                    email: payload.email,
                    userId: payload.sub,
                    name: payload.given_name || payload.email
                };
            } catch (error) {
                log('Error parsing token: ' + error.message);
                return null;
            }
        };

        const makeAuthenticatedRequest = async (url, options = {}) => {
            const token = getAuthToken();
            if (!token) {
                throw new Error('No authentication token found');
            }

            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json',
                ...options.headers
            };

            const response = await fetch(url, {
                ...options,
                headers
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            return response.json();
        };

        // Icons (same as original)
        const MicIcon = ({size = 24}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                <line x1="12" y1="19" x2="12" y2="23"/>
                <line x1="8" y1="23" x2="16" y2="23"/>
            </svg>
        );

        const SquareIcon = ({size = 24}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="currentColor">
                <rect x="6" y="6" width="12" height="12" rx="2"/>
            </svg>
        );

        const PlayIcon = ({size = 14}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="currentColor">
                <polygon points="5,3 19,12 5,21"/>
            </svg>
        );

        const PauseIcon = ({size = 14}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="currentColor">
                <rect x="6" y="4" width="4" height="16"/>
                <rect x="14" y="4" width="4" height="16"/>
            </svg>
        );

        const CheckIcon = ({size = 14}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="20,6 9,17 4,12"/>
            </svg>
        );

        const EditIcon = ({size = 14}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
            </svg>
        );

        const TrashIcon = ({size = 14}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="3,6 5,6 21,6"/>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            </svg>
        );

        const CloudIcon = ({size = 14}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"/>
            </svg>
        );

        function AudioRecorderApp() {
            const [user, setUser] = useState(null);
            const [isRecording, setIsRecording] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [chunkDuration, setChunkDuration] = useState(5);
            const [theme, setTheme] = useState('default');
            const [uploadStatus, setUploadStatus] = useState({});
            const [sessions, setSessions] = useState([]);
            
            // Audio recording state
            const mediaRecorderRef = useRef(null);
            const streamRef = useRef(null);
            const audioElementRef = useRef(null);
            const sessionStartRef = useRef(null);
            const currentChunkRef = useRef(0);
            const recordingSessionRef = useRef(null);
            const sessionIdRef = useRef(null);
            const chunksQueueRef = useRef([]);
            
            const [recordings, setRecordings] = useState([]);
            const [playingId, setPlayingId] = useState(null);

            // Check authentication on mount
            useEffect(() => {
                const currentUser = getUserFromToken();
                if (!currentUser) {
                    // Redirect to login
                    window.location.href = '/';
                    return;
                }
                
                setUser(currentUser);
                log(`Audio recorder initialized for user: ${currentUser.email}`);
                
                // Load previous sessions
                loadSessions();
            }, []);

            // Load user's audio sessions
            const loadSessions = async () => {
                try {
                    const response = await makeAuthenticatedRequest(`${config.audioApiUrl}/sessions`);
                    setSessions(response.sessions || []);
                    log(`Loaded ${response.sessions?.length || 0} audio sessions`);
                } catch (error) {
                    log(`Error loading sessions: ${error.message}`);
                }
            };

            // Generate human-readable session ID
            const generateSessionId = () => {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                  'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                const monthAbbr = monthNames[now.getMonth()];
                const day = String(now.getDate()).padStart(2, '0');
                const hour = String(now.getHours()).padStart(2, '0');
                const minute = String(now.getMinutes()).padStart(2, '0');
                const second = String(now.getSeconds()).padStart(2, '0');
                
                // Format: 2025.07(JUL).04-141530 (YYYY.MM(MON).DD-HHMMSS)
                return `${year}.${month}(${monthAbbr}).${day}-${hour}${minute}${second}`;
            };

            // Upload chunk to S3
            const uploadChunk = async (chunkBlob, chunkNumber) => {
                try {
                    log(`Uploading chunk ${chunkNumber} (${chunkBlob.size} bytes)`);
                    
                    // Get pre-signed URL
                    const uploadRequest = await makeAuthenticatedRequest(`${config.audioApiUrl}/upload-chunk`, {
                        method: 'POST',
                        body: JSON.stringify({
                            sessionId: sessionIdRef.current,
                            chunkNumber: chunkNumber,
                            contentType: 'audio/webm',
                            duration: chunkDuration
                        })
                    });

                    // Upload to S3
                    const uploadResponse = await fetch(uploadRequest.uploadUrl, {
                        method: 'PUT',
                        body: chunkBlob,
                        headers: {
                            'Content-Type': 'audio/webm'
                        }
                    });

                    if (!uploadResponse.ok) {
                        throw new Error(`Upload failed: ${uploadResponse.status}`);
                    }

                    // Update upload status
                    setUploadStatus(prev => ({
                        ...prev,
                        [chunkNumber]: 'uploaded'
                    }));

                    log(`Chunk ${chunkNumber} uploaded successfully`);
                    return true;
                } catch (error) {
                    log(`Error uploading chunk ${chunkNumber}: ${error.message}`);
                    setUploadStatus(prev => ({
                        ...prev,
                        [chunkNumber]: 'failed'
                    }));
                    return false;
                }
            };

            // Update session metadata
            const updateSessionMetadata = async (metadata) => {
                try {
                    await makeAuthenticatedRequest(`${config.audioApiUrl}/session-metadata`, {
                        method: 'POST',
                        body: JSON.stringify({
                            sessionId: sessionIdRef.current,
                            metadata: metadata
                        })
                    });
                    log('Session metadata updated');
                } catch (error) {
                    log(`Error updating metadata: ${error.message}`);
                }
            };

            // Timer effect
            useEffect(() => {
                let interval;
                if (isRecording) {
                    interval = setInterval(() => {
                        setCurrentTime(prev => {
                            const newTime = prev + 1;
                            
                            // Check if we need to create a new chunk
                            if (newTime > 0 && newTime % chunkDuration === 0) {
                                log(`Chunk ${currentChunkRef.current + 1} completed at ${newTime}s`);
                                createChunkFromCurrentRecording();
                            }
                            
                            return newTime;
                        });
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [isRecording, chunkDuration]);

            const formatTime = (seconds) => {
                if (isNaN(seconds) || seconds === Infinity || seconds < 0) return '00:00';
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
            };

            const formatSessionDisplay = (sessionId) => {
                try {
                    // Format: 2025.07(JUL).05-024630
                    const [datePart, timePart] = sessionId.split('-');
                    
                    if (!datePart || !timePart) return sessionId;
                    
                    // Parse date: 2025.07(JUL).05
                    const dateMatch = datePart.match(/(\d{4})\.(\d{2})\((\w{3})\)\.(\d{2})/);
                    if (!dateMatch) return sessionId;
                    
                    const [, year, month, monthName, day] = dateMatch;
                    
                    // Parse time: 024630 (HHMMSS)
                    const hour = timePart.substring(0, 2);
                    const minute = timePart.substring(2, 4);
                    const second = timePart.substring(4, 6);
                    
                    // Format as readable date and time
                    const formattedDate = `${monthName} ${day}, ${year}`;
                    const formattedTime = `${hour}:${minute}:${second}`;
                    
                    return `${formattedDate} at ${formattedTime}`;
                } catch (error) {
                    // Fallback to original sessionId if parsing fails
                    return sessionId;
                }
            };

            const createChunkFromCurrentRecording = async () => {
                if (!mediaRecorderRef.current || mediaRecorderRef.current.state !== 'recording') {
                    log("ERROR: Cannot create chunk - MediaRecorder not recording");
                    return;
                }

                try {
                    const chunks = [];
                    const oldRecorder = mediaRecorderRef.current;
                    
                    const chunkPromise = new Promise((resolve) => {
                        oldRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                chunks.push(event.data);
                            }
                        };
                        
                        oldRecorder.onstop = () => {
                            if (chunks.length > 0) {
                                const audioBlob = new Blob(chunks, { type: 'audio/webm;codecs=opus' });
                                resolve(audioBlob);
                            } else {
                                resolve(null);
                            }
                        };
                    });

                    oldRecorder.stop();
                    const audioBlob = await chunkPromise;
                    
                    if (audioBlob) {
                        const chunkNumber = currentChunkRef.current + 1;
                        currentChunkRef.current = chunkNumber;
                        
                        // Add to local recordings for playback
                        const audioUrl = URL.createObjectURL(audioBlob);
                        const newRecording = {
                            id: `${sessionIdRef.current}-chunk-${chunkNumber}`,
                            name: `Chunk ${chunkNumber}`,
                            sessionName: sessionIdRef.current,
                            duration: chunkDuration,
                            size: Number((audioBlob.size / (1024 * 1024)).toFixed(2)),
                            timestamp: new Date(),
                            chunkNumber: chunkNumber,
                            sessionId: sessionIdRef.current,
                            syncStatus: "uploading",
                            audioBlob,
                            audioUrl
                        };
                        
                        setRecordings(prev => [newRecording, ...prev]);
                        
                        // Upload chunk in background
                        setUploadStatus(prev => ({
                            ...prev,
                            [chunkNumber]: 'uploading'
                        }));
                        
                        uploadChunk(audioBlob, chunkNumber).then(success => {
                            if (success) {
                                setRecordings(prev => prev.map(r => 
                                    r.id === newRecording.id 
                                        ? { ...r, syncStatus: 'synced' }
                                        : r
                                ));
                            } else {
                                setRecordings(prev => prev.map(r => 
                                    r.id === newRecording.id 
                                        ? { ...r, syncStatus: 'failed' }
                                        : r
                                ));
                            }
                        });
                    }

                    // Start a new recorder if still recording
                    if (streamRef.current && isRecording) {
                        await startNewChunkRecording();
                    }

                } catch (error) {
                    log(`ERROR creating chunk: ${error.message}`);
                }
            };

            const startNewChunkRecording = async () => {
                try {
                    const mimeTypes = [
                        'audio/webm;codecs=opus',
                        'audio/webm',
                        'audio/mp4',
                        'audio/ogg;codecs=opus',
                        'audio/wav'
                    ];
                    
                    let selectedMimeType = '';
                    for (const mimeType of mimeTypes) {
                        if (MediaRecorder.isTypeSupported(mimeType)) {
                            selectedMimeType = mimeType;
                            break;
                        }
                    }
                    
                    const options = selectedMimeType ? { mimeType: selectedMimeType } : {};
                    const mediaRecorder = new MediaRecorder(streamRef.current, options);
                    
                    mediaRecorderRef.current = mediaRecorder;
                    
                    mediaRecorder.onerror = (event) => {
                        log(`MediaRecorder error: ${event.error}`);
                    };
                    
                    mediaRecorder.start();
                    log("New chunk recording started");
                    
                } catch (error) {
                    log(`ERROR starting new chunk: ${error.message}`);
                }
            };

            const initializeRecording = async () => {
                try {
                    log("Requesting microphone access...");
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        } 
                    });
                    
                    streamRef.current = stream;
                    sessionIdRef.current = generateSessionId();
                    sessionStartRef.current = Date.now();
                    currentChunkRef.current = 0;
                    
                    // Create initial session metadata
                    await updateSessionMetadata({
                        status: 'recording',
                        chunkDuration: chunkDuration,
                        createdAt: new Date().toISOString(),
                        conversationContext: 'Voice recording session'
                    });
                    
                    await startNewChunkRecording();
                    log(`Recording session ${sessionIdRef.current} initialized`);
                    return true;
                    
                } catch (error) {
                    log(`ERROR: Failed to initialize recording: ${error.message}`);
                    alert(`Microphone access failed: ${error.message}`);
                    return false;
                }
            };

            const handleRecord = async () => {
                if (isRecording) {
                    log("Stopping recording...");
                    
                    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
                        await createChunkFromCurrentRecording();
                    }
                    
                    if (streamRef.current) {
                        streamRef.current.getTracks().forEach(track => {
                            track.stop();
                        });
                    }
                    
                    // Update final session metadata
                    await updateSessionMetadata({
                        status: 'completed',
                        duration: currentTime,
                        chunkCount: currentChunkRef.current,
                        completedAt: new Date().toISOString()
                    });
                    
                    setIsRecording(false);
                    setCurrentTime(0);
                    currentChunkRef.current = 0;
                    
                    // Reload sessions
                    loadSessions();
                    
                } else {
                    log("Starting recording...");
                    const initialized = await initializeRecording();
                    if (initialized) {
                        setIsRecording(true);
                        setCurrentTime(0);
                        setUploadStatus({});
                    }
                }
            };

            const handlePlay = (id) => {
                const recording = recordings.find(r => r.id === id);
                if (!recording?.audioUrl) return;
                
                if (playingId === id) {
                    if (audioElementRef.current) {
                        audioElementRef.current.pause();
                        audioElementRef.current = null;
                    }
                    setPlayingId(null);
                } else {
                    if (audioElementRef.current) {
                        audioElementRef.current.pause();
                    }
                    
                    const audio = new Audio(recording.audioUrl);
                    audioElementRef.current = audio;
                    
                    audio.onended = () => {
                        setPlayingId(null);
                        audioElementRef.current = null;
                    };
                    
                    audio.play().then(() => {
                        setPlayingId(id);
                    }).catch(error => {
                        log(`Audio playback failed: ${error.message}`);
                        setPlayingId(null);
                    });
                }
            };

            const handleDelete = (id) => {
                const recording = recordings.find(r => r.id === id);
                if (recording?.audioUrl) {
                    URL.revokeObjectURL(recording.audioUrl);
                }
                
                if (playingId === id) {
                    if (audioElementRef.current) {
                        audioElementRef.current.pause();
                        audioElementRef.current = null;
                    }
                    setPlayingId(null);
                }
                
                setRecordings(prev => prev.filter(r => r.id !== id));
            };

            const getSyncStatusIcon = (syncStatus) => {
                switch (syncStatus) {
                    case 'synced': return <i className="fas fa-check"></i>;
                    case 'uploading': return <i className="fas fa-cloud-upload-alt"></i>;
                    case 'failed': return <i className="fas fa-exclamation-triangle"></i>;
                    default: return <i className="fas fa-clock"></i>;
                }
            };

            const getSyncStatusColor = (syncStatus) => {
                switch (syncStatus) {
                    case 'synced': return '#22c55e';
                    case 'uploading': return '#3b82f6';
                    case 'failed': return '#ef4444';
                    default: return '#6b7280';
                }
            };

            const themeClass = theme === 'default' ? '' : theme === 'dark' ? 'dark' : `theme-${theme}`;
            const currentChunkTime = currentTime % chunkDuration;
            const currentChunkNumber = Math.floor(currentTime / chunkDuration) + 1;

            if (!user) {
                return (
                    <div className="min-h-screen flex items-center justify-center">
                        <div className="text-center">
                            <h1>Loading...</h1>
                            <p>Checking authentication...</p>
                        </div>
                    </div>
                );
            }

            return (
                <div style={{minHeight: '100vh', background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'}}>
                    {/* Header - using inline styles for React compatibility */}
                    <div style={{
                        background: 'rgba(255, 255, 255, 0.95)',
                        backdropFilter: 'blur(10px)',
                        padding: '1rem 2rem',
                        boxShadow: '0 2px 20px rgba(0, 0, 0, 0.1)',
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        position: 'sticky',
                        top: 0,
                        zIndex: 100
                    }}>
                        <div style={{
                            display: 'flex',
                            alignItems: 'center',
                            fontSize: '1.5rem',
                            fontWeight: 'bold',
                            color: '#667eea'
                        }}>
                            <i className="fas fa-microphone" style={{marginRight: '0.5rem', fontSize: '1.8rem'}}></i>
                            Audio Recorder
                        </div>
                        <div style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: '1rem'
                        }}>
                            <div style={{
                                width: '40px',
                                height: '40px',
                                borderRadius: '50%',
                                background: 'linear-gradient(45deg, #667eea, #764ba2)',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                color: 'white',
                                fontWeight: 'bold'
                            }}>
                                {user.email.split('@')[0].substring(0, 2).toUpperCase()}
                            </div>
                            <span>{user.email}</span>
                            <a href="/?goto=files" style={{
                                background: '#6c757d',
                                color: 'white',
                                padding: '0.375rem 0.75rem',
                                borderRadius: '0.25rem',
                                textDecoration: 'none',
                                fontSize: '0.875rem',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '0.5rem'
                            }}>
                                <i className="fas fa-folder"></i>
                                Files
                            </a>
                        </div>
                    </div>

                    <div style={{
                        maxWidth: '1200px',
                        margin: '2rem auto',
                        padding: '0 2rem'
                    }}>
                        <div style={{
                            background: 'white',
                            borderRadius: '20px',
                            boxShadow: '0 20px 40px rgba(0, 0, 0, 0.1)',
                            overflow: 'hidden',
                            minHeight: '600px'
                        }}>
                            <div style={{padding: '2rem'}}>
                                <div style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    marginBottom: '1rem'
                                }}>
                                    <h2 style={{
                                        margin: 0,
                                        fontSize: '1.5rem',
                                        fontWeight: 'bold',
                                        color: '#333',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.5rem'
                                    }}>
                                        <i className="fas fa-microphone" style={{color: '#667eea'}}></i>
                                        Audio Recording Studio
                                    </h2>
                                    <span style={{fontSize: '14px', color: '#666'}}>
                                        {sessions.length} sessions
                                    </span>
                                </div>
                                <p style={{color: '#666', marginBottom: '2rem'}}>
                                    Record high-quality audio with automatic chunking and cloud storage
                                </p>
                                
                                <div style={{
                                    display: 'grid', 
                                    gridTemplateColumns: window.innerWidth < 768 ? '1fr' : '1fr 1fr', 
                                    gap: '2rem'
                                }}>
                                    {/* Recording Controls */}
                                    <div style={{
                                        background: '#ffffff',
                                        borderRadius: '15px',
                                        padding: '2rem',
                                        boxShadow: '0 4px 25px rgba(0, 0, 0, 0.1)',
                                        border: '1px solid #f0f0f0'
                                    }}>
                                        <div style={{display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '1.5rem'}}>
                                            <i className="fas fa-microphone" style={{color: '#667eea', fontSize: '1.2rem'}}></i>
                                            <h3 style={{fontSize: '1.25rem', fontWeight: 'bold', margin: 0, color: '#333'}}>Recording Controls</h3>
                                        </div>
                                
                                        <div style={{display: 'flex', alignItems: 'center', gap: '1rem', marginBottom: '1.5rem'}}>
                                            <button
                                                onClick={handleRecord}
                                                style={{
                                                    width: '60px', 
                                                    height: '60px', 
                                                    borderRadius: '50%',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    fontSize: '1.5rem',
                                                    border: 'none',
                                                    background: isRecording ? '#dc3545' : '#667eea',
                                                    color: 'white',
                                                    cursor: 'pointer',
                                                    transition: 'all 0.2s ease',
                                                    animation: isRecording ? 'pulse 1.5s infinite' : 'none'
                                                }}
                                                onMouseEnter={(e) => {
                                                    if (!isRecording) {
                                                        e.target.style.background = '#5a67d8';
                                                        e.target.style.transform = 'scale(1.05)';
                                                    }
                                                }}
                                                onMouseLeave={(e) => {
                                                    if (!isRecording) {
                                                        e.target.style.background = '#667eea';
                                                        e.target.style.transform = 'scale(1)';
                                                    }
                                                }}
                                            >
                                                {isRecording ? <SquareIcon size={24} /> : <MicIcon size={24} />}
                                            </button>
                                            
                                            <div style={{flex: 1}}>
                                                <div style={{fontSize: '1.25rem', fontFamily: 'monospace', fontWeight: 'bold', color: '#333'}}>
                                                    {formatTime(currentChunkTime)} / {formatTime(chunkDuration)}
                                                </div>
                                                <div style={{fontSize: '0.9rem', color: '#666'}}>
                                                    {isRecording ? `Chunk ${currentChunkNumber}` : "Ready to record"}
                                                </div>
                                                {isRecording && (
                                                    <div style={{fontSize: '0.8rem', color: '#999'}}>
                                                        Total: {formatTime(currentTime)} ‚Ä¢ {currentChunkRef.current} uploaded
                                                    </div>
                                                )}
                                            </div>
                                        </div>

                                        <div style={{marginBottom: '1rem'}}>
                                            <div style={{display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '0.5rem'}}>
                                                <span style={{fontSize: '0.9rem', color: '#666'}}>Chunk Duration</span>
                                                <span style={{
                                                    background: '#667eea', 
                                                    color: 'white', 
                                                    padding: '0.25rem 0.5rem', 
                                                    borderRadius: '12px',
                                                    fontSize: '0.8rem',
                                                    fontWeight: 'bold'
                                                }}>{chunkDuration}s</span>
                                            </div>
                                            <input
                                                type="range"
                                                min="5"
                                                max="300"
                                                step="5"
                                                value={chunkDuration}
                                                onChange={(e) => setChunkDuration(parseInt(e.target.value))}
                                                disabled={isRecording}
                                                style={{
                                                    width: '100%',
                                                    height: '6px',
                                                    borderRadius: '3px',
                                                    background: '#e0e7ff',
                                                    outline: 'none',
                                                    marginBottom: '0.5rem'
                                                }}
                                            />
                                            <div style={{display: 'flex', justifyContent: 'space-between', fontSize: '0.8rem', color: '#999'}}>
                                                <span>5s</span>
                                                <span>5min</span>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Recording Chunks */}
                                    <div style={{
                                        background: '#ffffff',
                                        borderRadius: '15px',
                                        padding: '2rem',
                                        boxShadow: '0 4px 25px rgba(0, 0, 0, 0.1)',
                                        border: '1px solid #f0f0f0'
                                    }}>
                                        <div style={{display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '1.5rem'}}>
                                            <i className="fas fa-waveform-lines" style={{color: '#667eea', fontSize: '1.2rem'}}></i>
                                            <h3 style={{fontSize: '1.25rem', fontWeight: 'bold', margin: 0, color: '#333'}}>Recording Chunks</h3>
                                            <span style={{
                                                background: '#f0f0f0', 
                                                color: '#666', 
                                                padding: '0.25rem 0.5rem', 
                                                borderRadius: '12px',
                                                fontSize: '0.8rem',
                                                marginLeft: 'auto'
                                            }}>({recordings.length})</span>
                                        </div>
                                        
                                        {sessionIdRef.current && (
                                            <div style={{
                                                background: '#f8f9ff', 
                                                padding: '0.75rem', 
                                                borderRadius: '8px', 
                                                marginBottom: '1rem',
                                                border: '1px solid #e0e7ff'
                                            }}>
                                                <div style={{fontSize: '0.9rem', color: '#667eea', fontWeight: '600', marginBottom: '0.25rem'}}>
                                                    üî¥ Recording Session
                                                </div>
                                                <div style={{fontSize: '0.8rem', color: '#6b7280', fontFamily: 'monospace'}}>
                                                    {formatSessionDisplay(sessionIdRef.current)}
                                                </div>
                                            </div>
                                        )}
                                
                                        <div style={{maxHeight: '400px', overflowY: 'auto'}}>
                                            {recordings.length === 0 ? (
                                                <div style={{
                                                    textAlign: 'center',
                                                    padding: '2rem',
                                                    color: '#999',
                                                    fontSize: '0.9rem'
                                                }}>
                                                    <i className="fas fa-play-circle" style={{fontSize: '2rem', marginBottom: '1rem', color: '#ccc'}}></i>
                                                    <div>No audio chunks yet</div>
                                                    <div>Start recording to see chunks appear here</div>
                                                </div>
                                            ) : (
                                                recordings.map((recording) => (
                                                    <div key={recording.id} style={{
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        padding: '1rem',
                                                        borderRadius: '12px',
                                                        marginBottom: '0.75rem',
                                                        border: '1px solid #e5e7eb',
                                                        background: '#ffffff',
                                                        transition: 'all 0.2s ease',
                                                        boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)',
                                                        ':hover': {
                                                            borderColor: '#d1d5db',
                                                            boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)'
                                                        }
                                                    }}
                                                    onMouseEnter={(e) => {
                                                        e.target.style.borderColor = '#d1d5db';
                                                        e.target.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
                                                    }}
                                                    onMouseLeave={(e) => {
                                                        e.target.style.borderColor = '#e5e7eb';
                                                        e.target.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.1)';
                                                    }}>
                                                        <button
                                                            onClick={() => handlePlay(recording.id)}
                                                            style={{
                                                                width: '36px',
                                                                height: '36px',
                                                                borderRadius: '8px',
                                                                border: '1px solid #e5e7eb',
                                                                background: playingId === recording.id ? '#f3f4f6' : '#f9fafb',
                                                                color: playingId === recording.id ? '#dc3545' : '#667eea',
                                                                display: 'flex',
                                                                alignItems: 'center',
                                                                justifyContent: 'center',
                                                                cursor: 'pointer',
                                                                marginRight: '0.75rem',
                                                                transition: 'all 0.2s ease',
                                                                fontSize: '12px',
                                                                boxShadow: '0 1px 2px rgba(0, 0, 0, 0.05)'
                                                            }}
                                                            onMouseEnter={(e) => {
                                                                e.target.style.background = playingId === recording.id ? '#e5e7eb' : '#f3f4f6';
                                                                e.target.style.borderColor = '#d1d5db';
                                                                e.target.style.transform = 'translateY(-1px)';
                                                                e.target.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
                                                            }}
                                                            onMouseLeave={(e) => {
                                                                e.target.style.background = playingId === recording.id ? '#f3f4f6' : '#f9fafb';
                                                                e.target.style.borderColor = '#e5e7eb';
                                                                e.target.style.transform = 'translateY(0)';
                                                                e.target.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.05)';
                                                            }}
                                                        >
                                                            <i className={playingId === recording.id ? 'fas fa-pause' : 'fas fa-play'}></i>
                                                        </button>
                                                        
                                                        <div style={{flex: 1}}>
                                                            <div style={{fontWeight: '600', color: '#333', fontSize: '0.9rem'}}>
                                                                {recording.name}
                                                            </div>
                                                            <div style={{fontSize: '0.75rem', color: '#666', display: 'flex', alignItems: 'center', gap: '0.5rem'}}>
                                                                <span>{recording.duration}s</span>
                                                                <span>‚Ä¢</span>
                                                                <span>{recording.size}MB</span>
                                                                <span>‚Ä¢</span>
                                                                <span style={{color: getSyncStatusColor(recording.syncStatus)}}>
                                                                    {getSyncStatusIcon(recording.syncStatus)}
                                                                </span>
                                                            </div>
                                                        </div>
                                                        
                                                        <button
                                                            onClick={() => handleDelete(recording.id)}
                                                            style={{
                                                                width: '32px',
                                                                height: '32px',
                                                                borderRadius: '6px',
                                                                border: '1px solid #e5e7eb',
                                                                background: '#f9fafb',
                                                                color: '#6b7280',
                                                                cursor: 'pointer',
                                                                display: 'flex',
                                                                alignItems: 'center',
                                                                justifyContent: 'center',
                                                                fontSize: '11px',
                                                                transition: 'all 0.2s ease',
                                                                boxShadow: '0 1px 2px rgba(0, 0, 0, 0.05)'
                                                            }}
                                                            onMouseEnter={(e) => {
                                                                e.target.style.background = '#fef2f2';
                                                                e.target.style.color = '#dc3545';
                                                                e.target.style.borderColor = '#fecaca';
                                                                e.target.style.transform = 'translateY(-1px)';
                                                                e.target.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
                                                            }}
                                                            onMouseLeave={(e) => {
                                                                e.target.style.background = '#f9fafb';
                                                                e.target.style.color = '#6b7280';
                                                                e.target.style.borderColor = '#e5e7eb';
                                                                e.target.style.transform = 'translateY(0)';
                                                                e.target.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.05)';
                                                            }}
                                                            title="Delete chunk"
                                                        >
                                                            <i className="fas fa-trash"></i>
                                                        </button>
                                                    </div>
                                                ))
                                            )}
                                        </div>
                                        
                                        {recordings.length > 0 && (
                                            <div style={{
                                                borderTop: '1px solid #f0f0f0',
                                                paddingTop: '1rem',
                                                marginTop: '1rem',
                                                fontSize: '0.8rem',
                                                color: '#666',
                                                textAlign: 'center'
                                            }}>
                                                Total: {recordings.length} chunks ‚Ä¢ Started: {sessionIdRef.current ? formatSessionDisplay(sessionIdRef.current) : 'None'}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Floating Action Button Component with inline styles for React compatibility
        function FloatingActionButton() {
            const FolderIcon = () => (
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                    <path d="M2 7h20"/>
                </svg>
            );
            
            return (
                <a href="/?goto=files" 
                   title="Back to Files"
                   style={{
                       position: 'fixed',
                       bottom: '24px',
                       right: '24px',
                       width: '64px',
                       height: '64px',
                       borderRadius: '50%',
                       background: 'white',
                       color: '#6b7280',
                       border: '2px solid #e5e7eb',
                       boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)',
                       display: 'flex',
                       alignItems: 'center',
                       justifyContent: 'center',
                       textDecoration: 'none',
                       zIndex: 1000,
                       transition: 'all 0.2s ease'
                   }}
                   onMouseEnter={(e) => {
                       e.target.style.transform = 'scale(1.05)';
                       e.target.style.boxShadow = '0 6px 16px rgba(0, 0, 0, 0.15)';
                   }}
                   onMouseLeave={(e) => {
                       e.target.style.transform = 'scale(1)';
                       e.target.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.1)';
                   }}
                >
                    <FolderIcon />
                </a>
            );
        }

        // Initialize when page loads - try multiple approaches
        function initializeApp() {
            console.log('Initializing AudioRecorderApp...');
            console.log('React available:', typeof React !== 'undefined');
            console.log('ReactDOM available:', typeof ReactDOM !== 'undefined');
            console.log('AudioRecorderApp available:', typeof AudioRecorderApp !== 'undefined');
            console.log('Root element exists:', !!document.getElementById('root'));
            
            if (typeof React !== 'undefined' && typeof ReactDOM !== 'undefined' && typeof AudioRecorderApp !== 'undefined') {
                try {
                    // Render both the main app and the FAB
                    ReactDOM.render(React.createElement(AudioRecorderApp), document.getElementById('root'));
                    
                    // Add FAB to body
                    const fabContainer = document.createElement('div');
                    document.body.appendChild(fabContainer);
                    ReactDOM.render(React.createElement(FloatingActionButton), fabContainer);
                    
                    console.log('AudioRecorderApp and FAB rendered successfully');
                } catch (error) {
                    console.error('Error rendering AudioRecorderApp:', error);
                }
            } else {
                console.log('Dependencies not ready, retrying in 500ms...');
                setTimeout(initializeApp, 500);
            }
        }

        // Try multiple initialization approaches
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
        
        // Fallback initialization
        setTimeout(initializeApp, 1000);

        // Test functions
        window.testRecord = () => {
            log("TEST: Starting test recording");
            setTimeout(() => {
                const event = new MouseEvent('click', { bubbles: true });
                document.querySelector('.btn-lg').dispatchEvent(event);
            }, 100);
        };

        window.testPlayback = () => {
            log("TEST: Testing playback");
            const playButton = document.querySelector('.btn-outline');
            if (playButton) {
                playButton.click();
            }
        };
    </script>
</body>
</html>